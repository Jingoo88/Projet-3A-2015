__author__ = 'gilles.drigout'

from abc import ABCMeta, abstractmethod
from numbapro.cudalib import curand
from numpy import zeros
from numbapro import cuda
import math

class Proposal:
    """
    Proposal class is an abstract class in providing an interface
    for all subsequent proposal values calculations.
    """

    __metaclass__ = ABCMeta

    def __init__(self, size):
        self.size = size


    @abstractmethod
    def generate_proposals(self):
        """
        An implementation is required to return proposal values
        :return: (numpy.array) proposal values
        """

    @abstractmethod
    def generate_omegas(self):
        """
        An implementation is required to return proposal values
        :return: (numpy.array) proposal values
        """



class ToyExample(Proposal):
    """
    Implementation of the Proposal class for Cauchy proposal using
    CUDA. Curand library is used to generate random numbers on the
    device.

    Since curand library does not natively support cauchy distribution,
    cauchy random variables are being generated by calculating ratio of
    standard normal distributions.
    """

    def __init__(self, size):
        """
        Constructor
        :param size: (int)
        """
        Proposal.__init__(self, size)
        # Number of threads per block is set to be 512, can be lowered
        # for older generation graphic cards
        self.threads_per_block = 512
        self.grid_dim = (self.size // self.threads_per_block ) +1
        self.host_values = zeros(self.size)
        self.device_values = self.generate_proposals()
        self.host_omegas = zeros(self.size)
        self.device_omegas = self.generate_omegas()


    @staticmethod
    @cuda.autojit
    def division(a, b, c, size):
        """
        Kernel to compute ratio of device arrays a/b
        :param a: (device array)
        :param b: (device array)
        :param c: (device array) contains values of a/b
        :param size: (int) size of device arrays
        """
        i = cuda.grid(1)
        if i < size:
            c[i] = a[i] / b[i]

    @staticmethod
    @cuda.autojit
    def omega(x, output, size):

        i = cuda.grid(1)
        if i < size:
            output[i] = (1.0 + x[i]**2)*math.exp(-0.5*x[i]**2)

    def generate_proposals(self):

        # Generating two device arrays of standard normals variables
        device_normals_1 = curand.normal(0, 1, self.size, device=True)
        device_normals_2 = curand.normal(0, 1, self.size, device=True)

        # Generating device array
        device_output = cuda.device_array_like(self.host_values)

        # Calling external kernel to calculate ratios of standard normals (in device)
        self.division[self.grid_dim, self.threads_per_block](device_normals_1, device_normals_2,
                                                             device_output, self.size)

        # Copying back values to host
        device_output.copy_to_host(self.host_values)

        return device_output

    def generate_omegas(self):

        # Generating device array
        device_output = cuda.device_array_like(self.host_omegas)

        # Calling kernel to calculate omegas
        self.omega[self.grid_dim, self.threads_per_block](self.device_values, device_output, self.size)

        # Copying back omegas to host
        device_output.copy_to_host(self.host_omegas)

        return device_output
